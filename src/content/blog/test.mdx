---
cover: "https://i.ytimg.com/vi/Wh3A29psE_Y/maxresdefault.jpg"
tabs:
    javascript: "console.log('Top K Frequent Elements');"
    python: "print('Top K Frequent Elements')"
title: "347. Top K Frequent Elements"
description: "Find the k most frequent elements in an array using heaps and hash maps."
date: "2023-12-29"
tags: ["swift", "cheatsheet"]
---

import CodeTabs from "../../components/code-tabs.astro";
import { injectCode } from "../../utils/blog-utils";
import { Code } from "astro:components";
import React from "react";

Imagine you're analyzing data from a music streaming service. You want to find the top 3 most played songs from a playlist. That's exactly what this problem helps us solve - finding the k most frequent elements in a list!

## Problem Statement

Given an array of numbers and an integer k, return the k most frequent elements. You can return
the answer in any order.

<CodeTabs
    tabs={{
        python:  injectCode(`
            from collections import Counter
            import heapq

            def topKFrequent(nums, k): # Count frequencies
                count = Counter(nums)

                # Keep k most frequent elements using min-heap
                heap = []
                for num, freq in count.items():
                    heapq.heappush(heap, (freq, num))
                    if len(heap) > k:
                        heapq.heappop(heap)

                # Extract results
                return [num for freq, num in heap]
        `),

        'c++':    injectCode(`
            class Solution {
                public:
                    vector<int> topKFrequent(vector<int>& nums, int k) {
                        unordered_map<int, int> count;
                        for (int num : nums) {
                            count[num]++;
                        }

                        priority_queue<pair<int, int>> pq;
                        for (auto& pair : count) {
                            pq.push({pair.second, pair.first});
                        }

                        vector<int> result;
                        while (k--) {
                            result.push_back(pq.top().second);
                            pq.pop();
                        }
                        return result;
                    }
                };
        `),

        java:   injectCode(`
            import java.util.HashMap;
            import java.util.Map;
            import java.util.PriorityQueue;

            class Solution {
                public int[] topKFrequent(int[] nums, int k) {
                    Map<Integer, Integer> count = new HashMap<>();
                    for (int num : nums) {
                        count.put(num, count.getOrDefault(num, 0) + 1);
                    }

                    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[1] - a[1]);
                    for (Map.Entry<Integer, Integer> entry : count.entrySet()) {
                        pq.offer(new int[] {
                                entry.getKey(), entry.getValue()
                        });
                    }

                    int[] result = new int[k];
                    for (int i = 0; i < k; i++) {
                        result[i] = pq.poll()[0];
                    }
                    return result;
                }
            }
        `),
    }}

/>

## Dry Run Example

Let's walk through the Python solution with `nums = [1,1,1,2,2,3]` and `k = 2`:

1. First, we count frequencies:

    ```python
    count = {1: 3, 2: 2, 3: 1}
    ```

2. Process each number:

    - `Add (3,1): heap = [(3,1)]`
    - `Add (2,2): heap = [(2,2), (3,1)]`
    - `Add (1,3): heap = [(2,2), (3,1)] # (1,3) gets removed as it's smallest`

3. Final result: [1,2]

## Time and Space Complexity

-   Time: O(n log k) where n is the length of nums
-   Space: O(n) for storing the frequency map

## Key Takeaways

1. Hash maps are perfect for counting frequencies
2. Heaps help us efficiently maintain top k elements
3. This pattern works for finding top k anything - most frequent words, most active users, etc.
